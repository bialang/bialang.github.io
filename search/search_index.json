{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Bia Dependencies No dependency is actually required, however, the bold printed dependecies are recommended and enabled by default. Dependency Usage Configuration Default std::thread BIA_THREAD_BACKEND=std::thread default and recommended Required for Testing Catch2 is required for testing and is in the repository included (no additional cloning). Building from Source Prerequisites: CMake (version 3.1) C++ compiler with at least C++11 support git The source code can be retrieved from GitHub with \u2764 git clone https://github.com/bialang/bia.git mkdir bia/build cd bia/build With CMake and the source code, the library can be build as follows: cmake .. -DCMAKE_BUILD_TYPE = Release cmake --build . We recommend running the test before installing the library: ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. cmake --build . --target install","title":"Home"},{"location":"index.html#welcome-to-bia","text":"","title":"Welcome to Bia"},{"location":"index.html#dependencies","text":"No dependency is actually required, however, the bold printed dependecies are recommended and enabled by default. Dependency Usage Configuration Default std::thread BIA_THREAD_BACKEND=std::thread default and recommended","title":"Dependencies"},{"location":"index.html#required-for-testing","text":"Catch2 is required for testing and is in the repository included (no additional cloning).","title":"Required for Testing"},{"location":"index.html#building-from-source","text":"Prerequisites: CMake (version 3.1) C++ compiler with at least C++11 support git The source code can be retrieved from GitHub with \u2764 git clone https://github.com/bialang/bia.git mkdir bia/build cd bia/build With CMake and the source code, the library can be build as follows: cmake .. -DCMAKE_BUILD_TYPE = Release cmake --build . We recommend running the test before installing the library: ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. cmake --build . --target install","title":"Building from Source"},{"location":"Engine/Engine.html","text":"Engine","title":"Engine"},{"location":"Engine/Engine.html#engine","text":"","title":"Engine"},{"location":"Engine/Memory.html","text":"Memory Garbage collector Stop the world Custom memory allocator","title":"Memory"},{"location":"Engine/Memory.html#memory","text":"","title":"Memory"},{"location":"Engine/Memory.html#garbage-collector","text":"","title":"Garbage collector"},{"location":"Engine/Memory.html#stop-the-world","text":"","title":"Stop the world"},{"location":"Engine/Memory.html#custom-memory-allocator","text":"","title":"Custom memory allocator"},{"location":"Engine/Op%20Codes.html","text":"Op Codes Parameter types Constant Member Source Member Destination Variantions 8 Bit Variants 4 Bit Variants 2 Bit Variants 0 Bit Variants Parameter types Constant Name Description Parameter Size Value int8 Signed int 8 bit 0 int16 Signed int 16 bit 1 int32 Signed int 32 bit 2 double IEEE 754 floating point 64 bit 3 Member Source Name Description Parameter Size Value tos Get top of stack 0 bit 0 args Get member with unsigned offset from arg position 8 bit 1 global16 local16 resource16 global8 local8 resource8 Member Destination Name Description Parameter Size Value tos Push on top of stack 0 bit 0 global16 local16 global8 local8 Variantions 8 Bit Variants Op Code 1. Parameter 2. Parameter 3. Parameter instantiate constant member destination n/a invoke uint8 parameter count member source member destination refer member source member destination n/a copy member source member destination n/a 4 Bit Variants Op Code 1. Parameter 2. Parameter invoke_void uint8 parameter count member source test member source n/a 2 Bit Variants Op Code 1. Parameter jump offset jump_true offset jump_false offset 0 Bit Variants Op Code return_void test_top","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#op-codes","text":"Parameter types Constant Member Source Member Destination Variantions 8 Bit Variants 4 Bit Variants 2 Bit Variants 0 Bit Variants","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#parameter-types","text":"","title":"Parameter types"},{"location":"Engine/Op%20Codes.html#constant","text":"Name Description Parameter Size Value int8 Signed int 8 bit 0 int16 Signed int 16 bit 1 int32 Signed int 32 bit 2 double IEEE 754 floating point 64 bit 3","title":"Constant"},{"location":"Engine/Op%20Codes.html#member-source","text":"Name Description Parameter Size Value tos Get top of stack 0 bit 0 args Get member with unsigned offset from arg position 8 bit 1 global16 local16 resource16 global8 local8 resource8","title":"Member Source"},{"location":"Engine/Op%20Codes.html#member-destination","text":"Name Description Parameter Size Value tos Push on top of stack 0 bit 0 global16 local16 global8 local8","title":"Member Destination"},{"location":"Engine/Op%20Codes.html#variantions","text":"","title":"Variantions"},{"location":"Engine/Op%20Codes.html#8-bit-variants","text":"Op Code 1. Parameter 2. Parameter 3. Parameter instantiate constant member destination n/a invoke uint8 parameter count member source member destination refer member source member destination n/a copy member source member destination n/a","title":"8 Bit Variants"},{"location":"Engine/Op%20Codes.html#4-bit-variants","text":"Op Code 1. Parameter 2. Parameter invoke_void uint8 parameter count member source test member source n/a","title":"4 Bit Variants"},{"location":"Engine/Op%20Codes.html#2-bit-variants","text":"Op Code 1. Parameter jump offset jump_true offset jump_false offset","title":"2 Bit Variants"},{"location":"Engine/Op%20Codes.html#0-bit-variants","text":"Op Code return_void test_top","title":"0 Bit Variants"},{"location":"Examples/Hello%20World.html","text":"Hello, World This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. #include <bia/bia.hpp> #include <bia/bsl/io.hpp> #include <iostream> #include <sstream> int main () { bia :: engine engine ; engine . function ( \"hello_world\" , + [] { std :: cout << \"Hello, World! - C++ \\n \" ; }); engine . module < bia :: bsl :: io > ( \"io\" , engine . gc ()); std :: stringstream code ; code << u8R \"( // prints 'Hello, World' to the console import io io . print ( \"Hello, World! - Bia\" ) // calls the C++ function and print 'Hello, World - C++' to the console hello_world () ) \"; engine . execute ( code ); }","title":"Hello World"},{"location":"Examples/Hello%20World.html#hello-world","text":"This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. #include <bia/bia.hpp> #include <bia/bsl/io.hpp> #include <iostream> #include <sstream> int main () { bia :: engine engine ; engine . function ( \"hello_world\" , + [] { std :: cout << \"Hello, World! - C++ \\n \" ; }); engine . module < bia :: bsl :: io > ( \"io\" , engine . gc ()); std :: stringstream code ; code << u8R \"( // prints 'Hello, World' to the console import io io . print ( \"Hello, World! - Bia\" ) // calls the C++ function and print 'Hello, World - C++' to the console hello_world () ) \"; engine . execute ( code ); }","title":"Hello, World"},{"location":"Introduction/Cheatsheet.html","text":"Cheatsheet The Engine A Bia engine can be initialized like this: #include <bia/bia.hpp> bia :: engine engine ; Executing a Script The bia::engine::execute function takes a std::istream for the script: #include <fstream> std :: ifstream file { \"myscript.bia\" }; engine . execute ( file ); Language Reference Variables let x = 0 let x = null // x is deleted Looping while true { let line = io . read ( \"> \" ) if not line { break } io . print ( \"< You said:\" , line ) } Conditionals if x and not y { io.print(x) } else if y { io.print(y) }","title":"Cheatsheet"},{"location":"Introduction/Cheatsheet.html#cheatsheet","text":"","title":"Cheatsheet"},{"location":"Introduction/Cheatsheet.html#the-engine","text":"A Bia engine can be initialized like this: #include <bia/bia.hpp> bia :: engine engine ;","title":"The Engine"},{"location":"Introduction/Cheatsheet.html#executing-a-script","text":"The bia::engine::execute function takes a std::istream for the script: #include <fstream> std :: ifstream file { \"myscript.bia\" }; engine . execute ( file );","title":"Executing a Script"},{"location":"Introduction/Cheatsheet.html#language-reference","text":"","title":"Language Reference"},{"location":"Introduction/Cheatsheet.html#variables","text":"let x = 0 let x = null // x is deleted","title":"Variables"},{"location":"Introduction/Cheatsheet.html#looping","text":"while true { let line = io . read ( \"> \" ) if not line { break } io . print ( \"< You said:\" , line ) }","title":"Looping"},{"location":"Introduction/Cheatsheet.html#conditionals","text":"if x and not y { io.print(x) } else if y { io.print(y) }","title":"Conditionals"},{"location":"Introduction/Embedding.html","text":"Embedding Bia's primary focus is to be easily embeddable into a C++11 application. For this purpose Bia exposes a simple wrapper class bia::engine (include <bia/bia.hpp> ). Native Functions Functions can be added with function , like: inline int square ( int x ) { return x * x ; } // static function engine . function ( \"square\" , & square ); // functor/lambda engine . function ( \"special\" , []( int x ) { return x * x ; }); Advanced Functions inline int sum ( bia :: connector :: parameters_type params ) { int s = 0 ; // all parameters for ( auto param : params ) { if ( param ) { s += bia :: cast < int > ( * param ); } } return s ; } engine . function ( \"sum\" , & sum );","title":"Embedding"},{"location":"Introduction/Embedding.html#embedding","text":"Bia's primary focus is to be easily embeddable into a C++11 application. For this purpose Bia exposes a simple wrapper class bia::engine (include <bia/bia.hpp> ).","title":"Embedding"},{"location":"Introduction/Embedding.html#native-functions","text":"Functions can be added with function , like: inline int square ( int x ) { return x * x ; } // static function engine . function ( \"square\" , & square ); // functor/lambda engine . function ( \"special\" , []( int x ) { return x * x ; });","title":"Native Functions"},{"location":"Introduction/Embedding.html#advanced-functions","text":"inline int sum ( bia :: connector :: parameters_type params ) { int s = 0 ; // all parameters for ( auto param : params ) { if ( param ) { s += bia :: cast < int > ( * param ); } } return s ; } engine . function ( \"sum\" , & sum );","title":"Advanced Functions"},{"location":"Introduction/Getting%20Started.html","text":"Getting Started After installing Bia it can be used in your CMake projects: find_package ( bialang REQUIRED ) add_executable ( main \"main.cpp\" ) target_link_libraries ( main PUBLIC bialang::bialang ) For simple embedding including <bia/bia.hpp> and using bia::engine should be enough.","title":"Getting Started"},{"location":"Introduction/Getting%20Started.html#getting-started","text":"After installing Bia it can be used in your CMake projects: find_package ( bialang REQUIRED ) add_executable ( main \"main.cpp\" ) target_link_libraries ( main PUBLIC bialang::bialang ) For simple embedding including <bia/bia.hpp> and using bia::engine should be enough.","title":"Getting Started"},{"location":"Specification/Flow%20Control.html","text":"Flow Control Conditionals if , else if and else if x { io.print(\"x evaluates to true\") } else if not y { io.print(\"x and y evaluate to false\") } else { io.print(\"why am i here\") } Loops while while x { io . print ( x ) if not y { break } x = y . something () }","title":"Flow Control"},{"location":"Specification/Flow%20Control.html#flow-control","text":"","title":"Flow Control"},{"location":"Specification/Flow%20Control.html#conditionals","text":"","title":"Conditionals"},{"location":"Specification/Flow%20Control.html#if-else-if-and-else","text":"if x { io.print(\"x evaluates to true\") } else if not y { io.print(\"x and y evaluate to false\") } else { io.print(\"why am i here\") }","title":"if, else if and else"},{"location":"Specification/Flow%20Control.html#loops","text":"","title":"Loops"},{"location":"Specification/Flow%20Control.html#while","text":"while x { io . print ( x ) if not y { break } x = y . something () }","title":"while"},{"location":"Specification/Functions.html","text":"Functions Parameters Positional Parameters Named Parameters Contracts Function Closures","title":"Functions"},{"location":"Specification/Functions.html#functions","text":"","title":"Functions"},{"location":"Specification/Functions.html#parameters","text":"","title":"Parameters"},{"location":"Specification/Functions.html#positional-parameters","text":"","title":"Positional Parameters"},{"location":"Specification/Functions.html#named-parameters","text":"","title":"Named Parameters"},{"location":"Specification/Functions.html#contracts","text":"","title":"Contracts"},{"location":"Specification/Functions.html#function-closures","text":"","title":"Function Closures"},{"location":"Specification/Keywords.html","text":"Keywords Keywords are special words is a specific meaning.","title":"Keywords"},{"location":"Specification/Keywords.html#keywords","text":"Keywords are special words is a specific meaning.","title":"Keywords"},{"location":"Specification/Scopes.html","text":"Scopes Global Scope In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Scopes"},{"location":"Specification/Scopes.html#scopes","text":"","title":"Scopes"},{"location":"Specification/Scopes.html#global-scope","text":"In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Global Scope"},{"location":"Specification/Variables.html","text":"Variables Declaration Variables are declared with the let keyword. Variables are by default read-only: let readonly = 0","title":"Variables"},{"location":"Specification/Variables.html#variables","text":"","title":"Variables"},{"location":"Specification/Variables.html#declaration","text":"Variables are declared with the let keyword. Variables are by default read-only: let readonly = 0","title":"Declaration"},{"location":"Syntax/Comments.html","text":"Comments Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: // next line prints : Hello , World io . print ( \"Hello, World\" ) /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Comments.html#comments","text":"Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: // next line prints : Hello , World io . print ( \"Hello, World\" ) /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Operators.html","text":"Operators Special Behavior of the Logical Operators Logical And If the left-hand side can be converted to true , the right-hand side is returned; otherwise the left-hand side is returned: io.print(99 and 61) // 61 io.print(0 and 61) // 0 Logical Or If the left-hand side can be converted to true , it is returned; otherwise the right-hand side is returned: io.print(99 or 61) // 99 io.print(0 or 61) // 61 Precedence The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shifts & bitwise and ^ bitwise xor | bitwise or <=> three-way comparison in , < , > , <= , >= , != , == including test and comparisons not logical not right-to-left and logical and or logical or","title":"Operators"},{"location":"Syntax/Operators.html#operators","text":"","title":"Operators"},{"location":"Syntax/Operators.html#special-behavior-of-the-logical-operators","text":"","title":"Special Behavior of the Logical Operators"},{"location":"Syntax/Operators.html#logical-and","text":"If the left-hand side can be converted to true , the right-hand side is returned; otherwise the left-hand side is returned: io.print(99 and 61) // 61 io.print(0 and 61) // 0","title":"Logical And"},{"location":"Syntax/Operators.html#logical-or","text":"If the left-hand side can be converted to true , it is returned; otherwise the right-hand side is returned: io.print(99 or 61) // 99 io.print(0 or 61) // 61","title":"Logical Or"},{"location":"Syntax/Operators.html#precedence","text":"The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shifts & bitwise and ^ bitwise xor | bitwise or <=> three-way comparison in , < , > , <= , >= , != , == including test and comparisons not logical not right-to-left and logical and or logical or","title":"Precedence"},{"location":"Types/Numbers.html","text":"Numbers Integers Integers in Bia range from -2^63 to 2^63-1 . Integer literals The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Base Literal Example Hexadecimal 0x or 0X 0xc0ffee Binary 0b or 0B 0b00100101 Ocatal 0 0777","title":"Numbers"},{"location":"Types/Numbers.html#numbers","text":"","title":"Numbers"},{"location":"Types/Numbers.html#integers","text":"Integers in Bia range from -2^63 to 2^63-1 .","title":"Integers"},{"location":"Types/Numbers.html#integer-literals","text":"The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Base Literal Example Hexadecimal 0x or 0X 0xc0ffee Binary 0b or 0B 0b00100101 Ocatal 0 0777","title":"Integer literals"},{"location":"Types/Regex.html","text":"Native Regular Expressions Syntax The pattern must be wrapped between / like following: let pattern = /ab+/ A / can be escaped with a \\ . The \\ only acts as a escape character in that perticular case. Note // is not a valid regex expression. See comments for more information. Modifiers 1 Modifiers come immediately after the enclosing / like: let pattern = /a.+/si Modifier Meaning Engine m ^ and $ match start/end of a line PCRE2; std::regex since C++17 i case insensitive matching all s . matches every character PCRE2 Supported underlying engines Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. std::regex default PCRE2 1 let engine_name = /./.name This feature has not been implemented yet. \u21a9 \u21a9","title":"Regex"},{"location":"Types/Regex.html#native-regular-expressions","text":"","title":"Native Regular Expressions"},{"location":"Types/Regex.html#syntax","text":"The pattern must be wrapped between / like following: let pattern = /ab+/ A / can be escaped with a \\ . The \\ only acts as a escape character in that perticular case. Note // is not a valid regex expression. See comments for more information.","title":"Syntax"},{"location":"Types/Regex.html#modifiers1","text":"Modifiers come immediately after the enclosing / like: let pattern = /a.+/si Modifier Meaning Engine m ^ and $ match start/end of a line PCRE2; std::regex since C++17 i case insensitive matching all s . matches every character PCRE2","title":"Modifiers1"},{"location":"Types/Regex.html#supported-underlying-engines","text":"Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. std::regex default PCRE2 1 let engine_name = /./.name This feature has not been implemented yet. \u21a9 \u21a9","title":"Supported underlying engines"},{"location":"Types/Strings.html","text":"String Comparing Strings Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. import io io . print ( \"bia\" == \"Bia\" ) // 0 io . print ( \"bia\" != \"Bia\" ) // 1 io . print ( \"Bia\" in \"I like Bia\" ) // 1 Iterating over Strings When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). let string = \"a\u304c\" // prints 3 print ( string . length ) Escape Characters The following escape sequences are valid if the string is not a raw string . Escape sequence Meaning \\ Backslash \\' Single quote \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab Guaranteed supported Encodings Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE Internal Storage Bia strings are stored as UTF-8 internally.","title":"Strings"},{"location":"Types/Strings.html#string","text":"","title":"String"},{"location":"Types/Strings.html#comparing-strings","text":"Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. import io io . print ( \"bia\" == \"Bia\" ) // 0 io . print ( \"bia\" != \"Bia\" ) // 1 io . print ( \"Bia\" in \"I like Bia\" ) // 1","title":"Comparing Strings"},{"location":"Types/Strings.html#iterating-over-strings","text":"When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). let string = \"a\u304c\" // prints 3 print ( string . length )","title":"Iterating over Strings"},{"location":"Types/Strings.html#escape-characters","text":"The following escape sequences are valid if the string is not a raw string . Escape sequence Meaning \\ Backslash \\' Single quote \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab","title":"Escape Characters"},{"location":"Types/Strings.html#guaranteed-supported-encodings","text":"Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE","title":"Guaranteed supported Encodings"},{"location":"Types/Strings.html#internal-storage","text":"Bia strings are stored as UTF-8 internally.","title":"Internal Storage"}]}