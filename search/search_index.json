{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Bia Bia is a statically and strongly typed programming language. The primary goal is to be able to embed it into C++ applications. There are also plans for C and Go ports. The second goal is to be a readable and intuitive language. Dependencies Bia does not need any dependencies apart from a C++11 compatible compiler and the standard library. Required for Testing Catch2 is required for testing and is in the repository included (no additional cloning). Building from Source Prerequisites: CMake (version 3.1) C++ compiler with at least C++11 support git The source code can be retrieved from GitHub . 1 2 git clone https://github.com/bialang/bia.git mkdir bia/build && cd bia/build With CMake and the source code, the library can be build as follows: 1 2 cmake .. cmake --build . We recommend running the test before installing the library: 1 ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. 1 cmake --build . --target install","title":"Home"},{"location":"index.html#welcome-to-bia","text":"Bia is a statically and strongly typed programming language. The primary goal is to be able to embed it into C++ applications. There are also plans for C and Go ports. The second goal is to be a readable and intuitive language.","title":"Welcome to Bia"},{"location":"index.html#dependencies","text":"Bia does not need any dependencies apart from a C++11 compatible compiler and the standard library.","title":"Dependencies"},{"location":"index.html#required-for-testing","text":"Catch2 is required for testing and is in the repository included (no additional cloning).","title":"Required for Testing"},{"location":"index.html#building-from-source","text":"Prerequisites: CMake (version 3.1) C++ compiler with at least C++11 support git The source code can be retrieved from GitHub . 1 2 git clone https://github.com/bialang/bia.git mkdir bia/build && cd bia/build With CMake and the source code, the library can be build as follows: 1 2 cmake .. cmake --build . We recommend running the test before installing the library: 1 ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. 1 cmake --build . --target install","title":"Building from Source"},{"location":"Engine/Engine.html","text":"Engine","title":"Engine"},{"location":"Engine/Engine.html#engine","text":"","title":"Engine"},{"location":"Engine/Memory.html","text":"Memory Garbage collector Stop the world Custom memory allocator","title":"Memory"},{"location":"Engine/Memory.html#memory","text":"","title":"Memory"},{"location":"Engine/Memory.html#garbage-collector","text":"","title":"Garbage collector"},{"location":"Engine/Memory.html#stop-the-world","text":"","title":"Stop the world"},{"location":"Engine/Memory.html#custom-memory-allocator","text":"","title":"Custom memory allocator"},{"location":"Engine/Op%20Codes.html","text":"Op Codes Memory Address A memory references a location on the stack. The value is an absolute offset from the start of the last stack frame. Operations Store Operation This operation stores an immediate value inside the specified location. 1 store <size> <destination>, <immediate> Copy Operation This operation copies the value of the source location to the destination location. 1 copy <size> <destination>, <source> Branch Operations 1 op <offset> Arguments Available Operations jmp : An unconditional jump. jmp_false : Jumps if the test register is equal to 0 . jmp_true : Jumps if the test register is not equal to 0 . Offset The offset is relative to the end of the branch instruction in bytes. With 2 Operands 1 op <size> <op1>, <op2> Arguments Available Operations add , fadd sub , fsub mul , fmul sdiv , udiv , fdiv srem , urem , frem : Remainder. and , or , xor : Bitwise operations. eq , neq , lt , leq , gt , geq : All standard comparison functions that yield a boolean. The final result is stored inside the test register. Available Sizes 8 , 16 , 32 , 64 First Operand op1 must be a memory address. The result of the operation is store here if not specified otherwise. Second Operand op2 must be either a memory address or an immediate. Examples The following examples demonstrate the use of the op codes. The actual compiler may optimize the code. In Bia: 1 2 3 let x = 0 let y = x + 0 let z = 1 + y 1 2 3 4 5 6 7 store 32 x, 0 cp 32 y, x add 32 y, 0 store 32 z, 1 add 32 z, y","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#op-codes","text":"","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#memory-address","text":"A memory references a location on the stack. The value is an absolute offset from the start of the last stack frame.","title":"Memory Address"},{"location":"Engine/Op%20Codes.html#operations","text":"","title":"Operations"},{"location":"Engine/Op%20Codes.html#store-operation","text":"This operation stores an immediate value inside the specified location. 1 store <size> <destination>, <immediate>","title":"Store Operation"},{"location":"Engine/Op%20Codes.html#copy-operation","text":"This operation copies the value of the source location to the destination location. 1 copy <size> <destination>, <source>","title":"Copy Operation"},{"location":"Engine/Op%20Codes.html#branch-operations","text":"1 op <offset>","title":"Branch Operations"},{"location":"Engine/Op%20Codes.html#arguments","text":"","title":"Arguments"},{"location":"Engine/Op%20Codes.html#available-operations","text":"jmp : An unconditional jump. jmp_false : Jumps if the test register is equal to 0 . jmp_true : Jumps if the test register is not equal to 0 .","title":"Available Operations"},{"location":"Engine/Op%20Codes.html#offset","text":"The offset is relative to the end of the branch instruction in bytes.","title":"Offset"},{"location":"Engine/Op%20Codes.html#with-2-operands","text":"1 op <size> <op1>, <op2>","title":"With 2 Operands"},{"location":"Engine/Op%20Codes.html#arguments_1","text":"","title":"Arguments"},{"location":"Engine/Op%20Codes.html#available-operations_1","text":"add , fadd sub , fsub mul , fmul sdiv , udiv , fdiv srem , urem , frem : Remainder. and , or , xor : Bitwise operations. eq , neq , lt , leq , gt , geq : All standard comparison functions that yield a boolean. The final result is stored inside the test register.","title":"Available Operations"},{"location":"Engine/Op%20Codes.html#available-sizes","text":"8 , 16 , 32 , 64","title":"Available Sizes"},{"location":"Engine/Op%20Codes.html#first-operand","text":"op1 must be a memory address. The result of the operation is store here if not specified otherwise.","title":"First Operand"},{"location":"Engine/Op%20Codes.html#second-operand","text":"op2 must be either a memory address or an immediate.","title":"Second Operand"},{"location":"Engine/Op%20Codes.html#examples","text":"The following examples demonstrate the use of the op codes. The actual compiler may optimize the code. In Bia: 1 2 3 let x = 0 let y = x + 0 let z = 1 + y 1 2 3 4 5 6 7 store 32 x, 0 cp 32 y, x add 32 y, 0 store 32 z, 1 add 32 z, y","title":"Examples"},{"location":"Engine/Stack.html","text":"Stack The stack of the virtual machine grows upwards. Stack Frame","title":"Stack"},{"location":"Engine/Stack.html#stack","text":"The stack of the virtual machine grows upwards.","title":"Stack"},{"location":"Engine/Stack.html#stack-frame","text":"","title":"Stack Frame"},{"location":"Examples/Hello%20World.html","text":"Hello, World This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bia/engine.hpp> #include <bia/bsl/io.hpp> #include <iostream> #include <sstream> int main () { bia :: Engine engine ; engine . function ( \"hello_world\" , + [] { std :: cout << \"Hello, World! - C++ \\n \" ; }); engine . module ( \"io\" , bia :: bsl :: io ); std :: stringstream code ; code << u8R \" ( // prints 'Hello, World' to the console import io io.print(\"Hello, World! - Bia\") // calls the C++ function and // print 'Hello, World - C++' to the console hello_world() ) \" ; engine . execute ( code ); }","title":"Hello World"},{"location":"Examples/Hello%20World.html#hello-world","text":"This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bia/engine.hpp> #include <bia/bsl/io.hpp> #include <iostream> #include <sstream> int main () { bia :: Engine engine ; engine . function ( \"hello_world\" , + [] { std :: cout << \"Hello, World! - C++ \\n \" ; }); engine . module ( \"io\" , bia :: bsl :: io ); std :: stringstream code ; code << u8R \" ( // prints 'Hello, World' to the console import io io.print(\"Hello, World! - Bia\") // calls the C++ function and // print 'Hello, World - C++' to the console hello_world() ) \" ; engine . execute ( code ); }","title":"Hello, World"},{"location":"Introduction/Cheatsheet.html","text":"Cheatsheet The Engine A Bia engine can be initialized like this: C++ 1 2 3 #include <bia/engine.hpp> bia :: Engine engine ; Executing a Script The execute() function of the engine takes a std::istream for the script. It compiles and runs the code immediately: C++ 1 2 3 4 #include <fstream> std :: ifstream file { \"myscript.bia\" }; engine . execute ( file ); Language Reference Variables 1 2 3 4 5 6 7 8 let x = 0 let x: int = 0 x = 1 // 'x' is immutable let mut x = 0 x = 0 // is now accepted drop x // 'x' is now unkown Scopes 1 2 3 4 scope { let x = 0 } print(x) // 'x' is undefined Looping Condition Based 1 2 3 4 5 6 7 while true { let line = io.read(\"> \") if not line { break } io.print(\"< You said:\", line) } Conditionals 1 2 3 4 5 if x and not y { io.print(x) } else if y { io.print(y) }","title":"Cheatsheet"},{"location":"Introduction/Cheatsheet.html#cheatsheet","text":"","title":"Cheatsheet"},{"location":"Introduction/Cheatsheet.html#the-engine","text":"A Bia engine can be initialized like this: C++ 1 2 3 #include <bia/engine.hpp> bia :: Engine engine ;","title":"The Engine"},{"location":"Introduction/Cheatsheet.html#executing-a-script","text":"The execute() function of the engine takes a std::istream for the script. It compiles and runs the code immediately: C++ 1 2 3 4 #include <fstream> std :: ifstream file { \"myscript.bia\" }; engine . execute ( file );","title":"Executing a Script"},{"location":"Introduction/Cheatsheet.html#language-reference","text":"","title":"Language Reference"},{"location":"Introduction/Cheatsheet.html#variables","text":"1 2 3 4 5 6 7 8 let x = 0 let x: int = 0 x = 1 // 'x' is immutable let mut x = 0 x = 0 // is now accepted drop x // 'x' is now unkown","title":"Variables"},{"location":"Introduction/Cheatsheet.html#scopes","text":"1 2 3 4 scope { let x = 0 } print(x) // 'x' is undefined","title":"Scopes"},{"location":"Introduction/Cheatsheet.html#looping","text":"","title":"Looping"},{"location":"Introduction/Cheatsheet.html#condition-based","text":"1 2 3 4 5 6 7 while true { let line = io.read(\"> \") if not line { break } io.print(\"< You said:\", line) }","title":"Condition Based"},{"location":"Introduction/Cheatsheet.html#conditionals","text":"1 2 3 4 5 if x and not y { io.print(x) } else if y { io.print(y) }","title":"Conditionals"},{"location":"Introduction/Embedding.html","text":"Embedding Bia's primary focus is to be easily embeddable into a C++11 application. For this purpose Bia exposes a simple wrapper class bia::engine (include <bia/bia.hpp> ). Variables C++ 1 2 3 engine . variable ( \"argc\" , argc ); engine . variable ( \"pi\" , 3.141 ); engine . variable ( \"path\" , std :: string { std :: getenv ( \"PATH\" ) }); Functions Simple Functions Functions can be added with function , like: C++ 1 2 3 4 5 6 7 8 9 10 inline int square ( int x ) { return x * x ; } // static function engine . function ( \"square\" , & square ); // functor/lambda engine . function ( \"special\" , []( int x ) { return x * x ; }); C Warning This part has not been implemented yet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static bia_creation_t square ( bia_parameters_t params , void * arg ) { bia_parameters_t param = 0 ; bia_creation_t result = 0 ; double x = 1.0 ; bia_parameters_at ( params , 0 , & param ); bia_member_cast_double ( param , & x ); bia_create_double ( x * x , & result ); return result ; } bia_engine_put_function ( engine , \"square\" , & square , 0 ); Variable Parameters C++ 1 2 3 4 5 6 7 8 9 10 11 inline std :: ptrdiff_t sum ( bia :: member :: function :: Varargs < std :: ptrdiff_t > params ) { std :: ptrdiff_t s = 0 ; for ( std :: size_t i = 0 ; i < args . size (); ++ i ) { s += args . at ( i ); } return s ; } engine . function ( \"sum\" , & sum ); Type Unions C++ Static 1 2 3 4 5 6 7 8 9 10 11 inline void print ( bia :: util :: Variant < std :: ptrdiff_t , std :: string > value ) { if ( value . is_type < std :: ptrdiff_t > ()) { std :: cout << \"<int>: \" << value . get < std :: ptrdiff_t > () << \" \\n \" ; } else { std :: cout << \"<str>: \" << value . get < std :: string > () << \" \\n \" ; } } engine . function ( \"print\" , & print ); Objects Object can be populated like the global namespace with variable() , function() and object() : C++ 1 2 3 4 auto obj = engine . object ( \"obj\" ); args . function ( \"hello\" , []( std :: string s ) { std :: cout << s << \" \\n \" ; }); args . variable ( \"world\" , std :: string { \"hello world\" }); args . finish (); Modules Runtime Modules Runtime modules are just like objects with the only exception that they are not available in the global namespace without any explicit import statement. Just like the example in the objects section: C++ 1 2 3 4 auto obj = engine . module ( \"obj\" ); args . function ( \"hello\" , []( std :: string s ) { std :: cout << s << \" \\n \" ; }); args . variable ( \"world\" , std :: string { \"hello world\" }); args . finish (); Note Note the difference in the first line between engine.object() and engine.module() . Usage in Bia: 1 2 import obj obj.hello(obj.world)","title":"Embedding"},{"location":"Introduction/Embedding.html#embedding","text":"Bia's primary focus is to be easily embeddable into a C++11 application. For this purpose Bia exposes a simple wrapper class bia::engine (include <bia/bia.hpp> ).","title":"Embedding"},{"location":"Introduction/Embedding.html#variables","text":"C++ 1 2 3 engine . variable ( \"argc\" , argc ); engine . variable ( \"pi\" , 3.141 ); engine . variable ( \"path\" , std :: string { std :: getenv ( \"PATH\" ) });","title":"Variables"},{"location":"Introduction/Embedding.html#functions","text":"","title":"Functions"},{"location":"Introduction/Embedding.html#simple-functions","text":"Functions can be added with function , like: C++ 1 2 3 4 5 6 7 8 9 10 inline int square ( int x ) { return x * x ; } // static function engine . function ( \"square\" , & square ); // functor/lambda engine . function ( \"special\" , []( int x ) { return x * x ; }); C Warning This part has not been implemented yet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static bia_creation_t square ( bia_parameters_t params , void * arg ) { bia_parameters_t param = 0 ; bia_creation_t result = 0 ; double x = 1.0 ; bia_parameters_at ( params , 0 , & param ); bia_member_cast_double ( param , & x ); bia_create_double ( x * x , & result ); return result ; } bia_engine_put_function ( engine , \"square\" , & square , 0 );","title":"Simple Functions"},{"location":"Introduction/Embedding.html#variable-parameters","text":"C++ 1 2 3 4 5 6 7 8 9 10 11 inline std :: ptrdiff_t sum ( bia :: member :: function :: Varargs < std :: ptrdiff_t > params ) { std :: ptrdiff_t s = 0 ; for ( std :: size_t i = 0 ; i < args . size (); ++ i ) { s += args . at ( i ); } return s ; } engine . function ( \"sum\" , & sum );","title":"Variable Parameters"},{"location":"Introduction/Embedding.html#type-unions","text":"C++ Static 1 2 3 4 5 6 7 8 9 10 11 inline void print ( bia :: util :: Variant < std :: ptrdiff_t , std :: string > value ) { if ( value . is_type < std :: ptrdiff_t > ()) { std :: cout << \"<int>: \" << value . get < std :: ptrdiff_t > () << \" \\n \" ; } else { std :: cout << \"<str>: \" << value . get < std :: string > () << \" \\n \" ; } } engine . function ( \"print\" , & print );","title":"Type Unions"},{"location":"Introduction/Embedding.html#objects","text":"Object can be populated like the global namespace with variable() , function() and object() : C++ 1 2 3 4 auto obj = engine . object ( \"obj\" ); args . function ( \"hello\" , []( std :: string s ) { std :: cout << s << \" \\n \" ; }); args . variable ( \"world\" , std :: string { \"hello world\" }); args . finish ();","title":"Objects"},{"location":"Introduction/Embedding.html#modules","text":"","title":"Modules"},{"location":"Introduction/Embedding.html#runtime-modules","text":"Runtime modules are just like objects with the only exception that they are not available in the global namespace without any explicit import statement. Just like the example in the objects section: C++ 1 2 3 4 auto obj = engine . module ( \"obj\" ); args . function ( \"hello\" , []( std :: string s ) { std :: cout << s << \" \\n \" ; }); args . variable ( \"world\" , std :: string { \"hello world\" }); args . finish (); Note Note the difference in the first line between engine.object() and engine.module() . Usage in Bia: 1 2 import obj obj.hello(obj.world)","title":"Runtime Modules"},{"location":"Introduction/Getting%20Started.html","text":"Getting Started After installing Bia it can be used in your CMake projects: 1 2 3 4 find_package ( bia REQUIRED ) add_executable ( main \"main.cpp\" ) target_link_libraries ( main PUBLIC bia::bia ) For simple embedding in C++ including <bia/bia.hpp> and using bia::engine should be enough. For the C Port including <bia/cbia.h> and using bia_engine_t should be enough. Go Warning This package has not been updated. Do not use it yet. 1 go get github.com/bialang/gobia Note You will need to have Bia installed on your machine in order to be able to use this interface.","title":"Getting Started"},{"location":"Introduction/Getting%20Started.html#getting-started","text":"After installing Bia it can be used in your CMake projects: 1 2 3 4 find_package ( bia REQUIRED ) add_executable ( main \"main.cpp\" ) target_link_libraries ( main PUBLIC bia::bia ) For simple embedding in C++ including <bia/bia.hpp> and using bia::engine should be enough. For the C Port including <bia/cbia.h> and using bia_engine_t should be enough.","title":"Getting Started"},{"location":"Introduction/Getting%20Started.html#go","text":"Warning This package has not been updated. Do not use it yet. 1 go get github.com/bialang/gobia Note You will need to have Bia installed on your machine in order to be able to use this interface.","title":"Go"},{"location":"Specification/Flow%20Control.html","text":"Flow Control Conditionals if , else if and else 1 2 3 4 5 6 7 if x { io.print(\"x evaluates to true\") } else if not y { io.print(\"x and y evaluate to false\") } else { io.print(\"why am i here\") } Loops while 1 2 3 4 5 6 7 while x { io.print(x) if not y { break } x = y.something() } for...in 1 2 3 for i in range(10) { io.print(i) } In this case the variable i will be declared only for the loop and will not be available outside of the scope. If a variable already existed with the same name, it will be overshadowed.","title":"Flow Control"},{"location":"Specification/Flow%20Control.html#flow-control","text":"","title":"Flow Control"},{"location":"Specification/Flow%20Control.html#conditionals","text":"","title":"Conditionals"},{"location":"Specification/Flow%20Control.html#if-else-if-and-else","text":"1 2 3 4 5 6 7 if x { io.print(\"x evaluates to true\") } else if not y { io.print(\"x and y evaluate to false\") } else { io.print(\"why am i here\") }","title":"if, else if and else"},{"location":"Specification/Flow%20Control.html#loops","text":"","title":"Loops"},{"location":"Specification/Flow%20Control.html#while","text":"1 2 3 4 5 6 7 while x { io.print(x) if not y { break } x = y.something() }","title":"while"},{"location":"Specification/Flow%20Control.html#forin","text":"1 2 3 for i in range(10) { io.print(i) } In this case the variable i will be declared only for the loop and will not be available outside of the scope. If a variable already existed with the same name, it will be overshadowed.","title":"for...in"},{"location":"Specification/Functions.html","text":"Functions Parameters Positional Parameters Named Parameters Contracts Function Closures","title":"Functions"},{"location":"Specification/Functions.html#functions","text":"","title":"Functions"},{"location":"Specification/Functions.html#parameters","text":"","title":"Parameters"},{"location":"Specification/Functions.html#positional-parameters","text":"","title":"Positional Parameters"},{"location":"Specification/Functions.html#named-parameters","text":"","title":"Named Parameters"},{"location":"Specification/Functions.html#contracts","text":"","title":"Contracts"},{"location":"Specification/Functions.html#function-closures","text":"","title":"Function Closures"},{"location":"Specification/Keywords.html","text":"Keywords Keywords are special words with a specific meaning. Keywords cannot be used as identifiers. let for in not , and and or while if else Builtins list range","title":"Keywords"},{"location":"Specification/Keywords.html#keywords","text":"Keywords are special words with a specific meaning. Keywords cannot be used as identifiers. let for in not , and and or while if else","title":"Keywords"},{"location":"Specification/Keywords.html#builtins","text":"list range","title":"Builtins"},{"location":"Specification/Scopes.html","text":"Scopes Global Scope In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Scopes"},{"location":"Specification/Scopes.html#scopes","text":"","title":"Scopes"},{"location":"Specification/Scopes.html#global-scope","text":"In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Global Scope"},{"location":"Specification/Variables.html","text":"Variables Declaration Variables are declared with the let keyword. Variables are by default read-only: 1 let readonly = 0","title":"Variables"},{"location":"Specification/Variables.html#variables","text":"","title":"Variables"},{"location":"Specification/Variables.html#declaration","text":"Variables are declared with the let keyword. Variables are by default read-only: 1 let readonly = 0","title":"Declaration"},{"location":"Syntax/Comments.html","text":"Comments Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: 1 2 3 4 5 6 7 8 9 10 11 // next line prints: Hello, World io.print(\"Hello, World\") /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Comments.html#comments","text":"Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: 1 2 3 4 5 6 7 8 9 10 11 // next line prints: Hello, World io.print(\"Hello, World\") /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Operators.html","text":"Operators Special Behavior of the Logical Operators Logical And If the left-hand side can be converted to true , the right-hand side is returned; otherwise the left-hand side is returned: 1 2 io.print(99 and 61) // 61 io.print(0 and 61) // 0 Logical Or If the left-hand side can be converted to true , it is returned; otherwise the right-hand side is returned: 1 2 io.print(99 or 61) // 99 io.print(0 or 61) // 61 Precedence The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shifts & bitwise and ^ bitwise xor | bitwise or <=> three-way comparison in , < , > , <= , >= , != , == including test and comparisons not logical not right-to-left and logical and or logical or","title":"Operators"},{"location":"Syntax/Operators.html#operators","text":"","title":"Operators"},{"location":"Syntax/Operators.html#special-behavior-of-the-logical-operators","text":"","title":"Special Behavior of the Logical Operators"},{"location":"Syntax/Operators.html#logical-and","text":"If the left-hand side can be converted to true , the right-hand side is returned; otherwise the left-hand side is returned: 1 2 io.print(99 and 61) // 61 io.print(0 and 61) // 0","title":"Logical And"},{"location":"Syntax/Operators.html#logical-or","text":"If the left-hand side can be converted to true , it is returned; otherwise the right-hand side is returned: 1 2 io.print(99 or 61) // 99 io.print(0 or 61) // 61","title":"Logical Or"},{"location":"Syntax/Operators.html#precedence","text":"The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shifts & bitwise and ^ bitwise xor | bitwise or <=> three-way comparison in , < , > , <= , >= , != , == including test and comparisons not logical not right-to-left and logical and or logical or","title":"Precedence"},{"location":"Types/List.html","text":"List builtin list 1 2 3 4 5 6 let empty = list() let my_list = list(1, \"the second element\", 3) for element in my_list { io.print(element) } Members push(elements...) pushes all given elements to the list pop(n=1) removes the last n elements clear() empties the list size the current size of the list capacity the capacity of the; this value describes after what size a push triggers a resize empty if the list is empty front the first element of the list back the last element of the list reserve(capacity) reserves more space shrink_to_fit() shrinks the list and releases unused memory insert(index, elements...) inserts the elements at the given index erase(index, n=1) erases from index n elements reverse() reverses the list inplace","title":"List"},{"location":"Types/List.html#list","text":"","title":"List"},{"location":"Types/List.html#builtin-list","text":"1 2 3 4 5 6 let empty = list() let my_list = list(1, \"the second element\", 3) for element in my_list { io.print(element) }","title":"builtin list"},{"location":"Types/List.html#members","text":"push(elements...) pushes all given elements to the list pop(n=1) removes the last n elements clear() empties the list size the current size of the list capacity the capacity of the; this value describes after what size a push triggers a resize empty if the list is empty front the first element of the list back the last element of the list reserve(capacity) reserves more space shrink_to_fit() shrinks the list and releases unused memory insert(index, elements...) inserts the elements at the given index erase(index, n=1) erases from index n elements reverse() reverses the list inplace","title":"Members"},{"location":"Types/Numbers.html","text":"Numbers Integers Integers in Bia range from -2^63 to 2^63-1 . Integer literals The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Base Literal Example Hexadecimal 0x or 0X 0xc0ffee Binary 0b or 0B 0b00100101 Ocatal 0 0777","title":"Numbers"},{"location":"Types/Numbers.html#numbers","text":"","title":"Numbers"},{"location":"Types/Numbers.html#integers","text":"Integers in Bia range from -2^63 to 2^63-1 .","title":"Integers"},{"location":"Types/Numbers.html#integer-literals","text":"The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Base Literal Example Hexadecimal 0x or 0X 0xc0ffee Binary 0b or 0B 0b00100101 Ocatal 0 0777","title":"Integer literals"},{"location":"Types/Regex.html","text":"Native Regular Expressions Syntax The pattern must be wrapped between r\" and \" like following: 1 let pattern = r\"ab+\" Examples 1 2 3 4 5 6 7 8 9 10 11 12 // matches any digit let pattern = r\"\\d+\" io.print(pattern == \"65\") // 1 io.print(pattern in \"some string\") // 0 io.print(pattern in \"i am 21 years old\") // 1 io.print(pattern.match(\"i am 21 years old\")) // <null> io.print(pattern.search(\"i am 21 years old\").group(0)) // 21 for i in pattern.match_all(\"18.07.2020\") { io.print(i.group(0)) } Modifiers This has not been implemented yet Modifiers come immediately after the regex without any spaces: 1 let pattern = r\"a.+\"si Modifier Meaning Engine m ^ and $ match start/end of a line PCRE2; std::regex since C++17 i case insensitive matching all s . matches every character PCRE2 Supported underlying engines Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. std::regex default PCRE2 not supported 1 let engine_name = r\"\".name","title":"Regex"},{"location":"Types/Regex.html#native-regular-expressions","text":"","title":"Native Regular Expressions"},{"location":"Types/Regex.html#syntax","text":"The pattern must be wrapped between r\" and \" like following: 1 let pattern = r\"ab+\"","title":"Syntax"},{"location":"Types/Regex.html#examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 // matches any digit let pattern = r\"\\d+\" io.print(pattern == \"65\") // 1 io.print(pattern in \"some string\") // 0 io.print(pattern in \"i am 21 years old\") // 1 io.print(pattern.match(\"i am 21 years old\")) // <null> io.print(pattern.search(\"i am 21 years old\").group(0)) // 21 for i in pattern.match_all(\"18.07.2020\") { io.print(i.group(0)) }","title":"Examples"},{"location":"Types/Regex.html#modifiers","text":"This has not been implemented yet Modifiers come immediately after the regex without any spaces: 1 let pattern = r\"a.+\"si Modifier Meaning Engine m ^ and $ match start/end of a line PCRE2; std::regex since C++17 i case insensitive matching all s . matches every character PCRE2","title":"Modifiers"},{"location":"Types/Regex.html#supported-underlying-engines","text":"Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. std::regex default PCRE2 not supported 1 let engine_name = r\"\".name","title":"Supported underlying engines"},{"location":"Types/Strings.html","text":"String Comparing Strings Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. 1 2 3 4 5 import io io.print(\"bia\" == \"Bia\") // 0 io.print(\"bia\" != \"Bia\") // 1 io.print(\"Bia\" in \"I like Bia\") // 1 Members length the length of the strings (number of bytes not code points) lower() returns a copy of this string in lowercase upper() returns a copy of this string in uppercase Iterating over Strings This section is out of date When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). 1 2 3 4 let string = \"a\u304c\" // prints 3 print(string.length) Escape Characters Escape sequence Meaning \\ Backslash \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab Guaranteed supported Encodings Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE Internal Storage Bia strings are stored as UTF-8 internally.","title":"Strings"},{"location":"Types/Strings.html#string","text":"","title":"String"},{"location":"Types/Strings.html#comparing-strings","text":"Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. 1 2 3 4 5 import io io.print(\"bia\" == \"Bia\") // 0 io.print(\"bia\" != \"Bia\") // 1 io.print(\"Bia\" in \"I like Bia\") // 1","title":"Comparing Strings"},{"location":"Types/Strings.html#members","text":"length the length of the strings (number of bytes not code points) lower() returns a copy of this string in lowercase upper() returns a copy of this string in uppercase","title":"Members"},{"location":"Types/Strings.html#iterating-over-strings","text":"This section is out of date When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). 1 2 3 4 let string = \"a\u304c\" // prints 3 print(string.length)","title":"Iterating over Strings"},{"location":"Types/Strings.html#escape-characters","text":"Escape sequence Meaning \\ Backslash \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab","title":"Escape Characters"},{"location":"Types/Strings.html#guaranteed-supported-encodings","text":"Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE","title":"Guaranteed supported Encodings"},{"location":"Types/Strings.html#internal-storage","text":"Bia strings are stored as UTF-8 internally.","title":"Internal Storage"}]}