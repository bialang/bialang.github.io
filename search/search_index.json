{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Bia For full documentation visit mkdocs.org . Dependencies No dependency is actually required, however, the bold printed dependecies are recommended and enabled by default. Dependency Usage Configuration ICU String encoding conversion BIA_STRING_ENCODING_BACKEND=ICU MPIR Integrated big numbers BIA_BIG_INT_BACKEND=MPIR PCRE2 BIA_REGEX_BACKEND=PCRE2 std::regex BIA_REGEX_BACKEND=std::regex boost::regex BIA_REGEX_BACKEND=boost::regex std::thread BIA_THREAD_BACKEND=std::thread boost::thread BIA_THREAD_BACKEND=boost::thread Required for Testing Catch2 is required for testing and is in the repository included (no additional cloning). Building from Source Prerequisites: CMake at least Version 3.1 C++ Compiler with at least C++11 support Git The source code can be retrieved from GitHub with \u2764 git clone https://github.com/bialang/bia.git mkdir bia/build cd bia/build With CMake and the source code, the library can be build as follows: cmake .. -DCMAKE_BUILD_TYPE = Release cmake --build . We recommend running the test before installing the library: ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. cmake --build . --target install","title":"Home"},{"location":"index.html#welcome-to-bia","text":"For full documentation visit mkdocs.org .","title":"Welcome to Bia"},{"location":"index.html#dependencies","text":"No dependency is actually required, however, the bold printed dependecies are recommended and enabled by default. Dependency Usage Configuration ICU String encoding conversion BIA_STRING_ENCODING_BACKEND=ICU MPIR Integrated big numbers BIA_BIG_INT_BACKEND=MPIR PCRE2 BIA_REGEX_BACKEND=PCRE2 std::regex BIA_REGEX_BACKEND=std::regex boost::regex BIA_REGEX_BACKEND=boost::regex std::thread BIA_THREAD_BACKEND=std::thread boost::thread BIA_THREAD_BACKEND=boost::thread","title":"Dependencies"},{"location":"index.html#required-for-testing","text":"Catch2 is required for testing and is in the repository included (no additional cloning).","title":"Required for Testing"},{"location":"index.html#building-from-source","text":"Prerequisites: CMake at least Version 3.1 C++ Compiler with at least C++11 support Git The source code can be retrieved from GitHub with \u2764 git clone https://github.com/bialang/bia.git mkdir bia/build cd bia/build With CMake and the source code, the library can be build as follows: cmake .. -DCMAKE_BUILD_TYPE = Release cmake --build . We recommend running the test before installing the library: ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. cmake --build . --target install","title":"Building from Source"},{"location":"Engine/Engine.html","text":"Engine","title":"Engine"},{"location":"Engine/Engine.html#engine","text":"","title":"Engine"},{"location":"Engine/Memory.html","text":"Memory Garbage collector Stop the world Custom memory allocator","title":"Memory"},{"location":"Engine/Memory.html#memory","text":"","title":"Memory"},{"location":"Engine/Memory.html#garbage-collector","text":"","title":"Garbage collector"},{"location":"Engine/Memory.html#stop-the-world","text":"","title":"Stop the world"},{"location":"Engine/Memory.html#custom-memory-allocator","text":"","title":"Custom memory allocator"},{"location":"Engine/Op%20Codes.html","text":"Op Codes Parameter types Constant Member Source Member Destination Variantions 8 Bit Variants 4 Bit Variants 2 Bit Variants 0 Bit Variants Parameter types Constant Name Description Parameter Size Value int8 Signed int 8 bit 0 int16 Signed int 16 bit 1 int32 Signed int 32 bit 2 double IEEE 754 floating point 64 bit 3 Member Source Name Description Parameter Size Value tos Get top of stack 0 bit 0 args Get member with unsigned offset from arg position 8 bit 1 global16 local16 resource16 global8 local8 resource8 Member Destination Name Description Parameter Size Value tos Push on top of stack 0 bit 0 global16 local16 global8 local8 Variantions 8 Bit Variants Op Code 1. Parameter 2. Parameter 3. Parameter instantiate constant member destination n/a invoke uint8 parameter count member source member destination refer member source member destination n/a copy member source member destination n/a 4 Bit Variants Op Code 1. Parameter 2. Parameter invoke_void uint8 parameter count member source test member source n/a 2 Bit Variants Op Code 1. Parameter jump offset jump_true offset jump_false offset 0 Bit Variants Op Code return_void test_top","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#op-codes","text":"Parameter types Constant Member Source Member Destination Variantions 8 Bit Variants 4 Bit Variants 2 Bit Variants 0 Bit Variants","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#parameter-types","text":"","title":"Parameter types"},{"location":"Engine/Op%20Codes.html#constant","text":"Name Description Parameter Size Value int8 Signed int 8 bit 0 int16 Signed int 16 bit 1 int32 Signed int 32 bit 2 double IEEE 754 floating point 64 bit 3","title":"Constant"},{"location":"Engine/Op%20Codes.html#member-source","text":"Name Description Parameter Size Value tos Get top of stack 0 bit 0 args Get member with unsigned offset from arg position 8 bit 1 global16 local16 resource16 global8 local8 resource8","title":"Member Source"},{"location":"Engine/Op%20Codes.html#member-destination","text":"Name Description Parameter Size Value tos Push on top of stack 0 bit 0 global16 local16 global8 local8","title":"Member Destination"},{"location":"Engine/Op%20Codes.html#variantions","text":"","title":"Variantions"},{"location":"Engine/Op%20Codes.html#8-bit-variants","text":"Op Code 1. Parameter 2. Parameter 3. Parameter instantiate constant member destination n/a invoke uint8 parameter count member source member destination refer member source member destination n/a copy member source member destination n/a","title":"8 Bit Variants"},{"location":"Engine/Op%20Codes.html#4-bit-variants","text":"Op Code 1. Parameter 2. Parameter invoke_void uint8 parameter count member source test member source n/a","title":"4 Bit Variants"},{"location":"Engine/Op%20Codes.html#2-bit-variants","text":"Op Code 1. Parameter jump offset jump_true offset jump_false offset","title":"2 Bit Variants"},{"location":"Engine/Op%20Codes.html#0-bit-variants","text":"Op Code return_void test_top","title":"0 Bit Variants"},{"location":"Examples/Hello%20World.html","text":"Hello, World This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. #include <bia/bia.hpp> #include <iostream> inline void hello_world () { std :: cout << \"Hello, World! - C++ \\n \" ; } int main () { bia :: engine eng ; eng . fun ( \"hello_world\" , & hello_world ); eng . execute ( R \" ( import io let name = \"Bia\" io.print(f\"Hello, World! - {name}\") hello_world() ) \" ); }","title":"Hello World"},{"location":"Examples/Hello%20World.html#hello-world","text":"This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. #include <bia/bia.hpp> #include <iostream> inline void hello_world () { std :: cout << \"Hello, World! - C++ \\n \" ; } int main () { bia :: engine eng ; eng . fun ( \"hello_world\" , & hello_world ); eng . execute ( R \" ( import io let name = \"Bia\" io.print(f\"Hello, World! - {name}\") hello_world() ) \" ); }","title":"Hello, World"},{"location":"Introduction/Embedding.html","text":"Embedding Bia's primary focus is to be easily embeddable into a C++11 application. Adding functions Functions can be added with add_func , like: // static function engine . fun ( \"some_function\" , & some_function ); // lambda function engine . fun ( \"special_function\" , [ & ] ( int x ) { /* cool stuff */ }); // member function engine . add_class < some_class > ( \"some_class\" ) . fun ( \"some_function\" , & some_class :: some_function ); Functions with default parameters Functions can have default parameters which are default constructed if not provided in the Bia script. The amount of optional parameters is given as template values: void add ( int x0 , int x1 , int x2 , int x3 ) { std :: cout << \"result: \" << x0 + x1 + x2 + x3 << \" \\n \" ; } engine . add_func < 2 > ( \"weird_add\" , & add ); With this the following Bia script is valid: // these all work because the int parameters are default constructed and get a value of 0 weird_add ( 1 , 2 ) weird_add ( 1 , 3 , 4 ) weird_add ( 4 , 2 , 1 , 4 ) // doesn ' t work because at least on parameter is missing weird_add ( 1 ) Adding classes Classes can be added with add_class . The returned object represents the class view.","title":"Embedding"},{"location":"Introduction/Embedding.html#embedding","text":"Bia's primary focus is to be easily embeddable into a C++11 application.","title":"Embedding"},{"location":"Introduction/Embedding.html#adding-functions","text":"Functions can be added with add_func , like: // static function engine . fun ( \"some_function\" , & some_function ); // lambda function engine . fun ( \"special_function\" , [ & ] ( int x ) { /* cool stuff */ }); // member function engine . add_class < some_class > ( \"some_class\" ) . fun ( \"some_function\" , & some_class :: some_function );","title":"Adding functions"},{"location":"Introduction/Embedding.html#functions-with-default-parameters","text":"Functions can have default parameters which are default constructed if not provided in the Bia script. The amount of optional parameters is given as template values: void add ( int x0 , int x1 , int x2 , int x3 ) { std :: cout << \"result: \" << x0 + x1 + x2 + x3 << \" \\n \" ; } engine . add_func < 2 > ( \"weird_add\" , & add ); With this the following Bia script is valid: // these all work because the int parameters are default constructed and get a value of 0 weird_add ( 1 , 2 ) weird_add ( 1 , 3 , 4 ) weird_add ( 4 , 2 , 1 , 4 ) // doesn ' t work because at least on parameter is missing weird_add ( 1 )","title":"Functions with default parameters"},{"location":"Introduction/Embedding.html#adding-classes","text":"Classes can be added with add_class . The returned object represents the class view.","title":"Adding classes"},{"location":"Introduction/Getting%20Started.html","text":"Getting Started","title":"Getting Started"},{"location":"Introduction/Getting%20Started.html#getting-started","text":"","title":"Getting Started"},{"location":"Specification/Functions.html","text":"Functions Parameters Positional Parameters Named Parameters Contracts Function Closures","title":"Functions"},{"location":"Specification/Functions.html#functions","text":"","title":"Functions"},{"location":"Specification/Functions.html#parameters","text":"","title":"Parameters"},{"location":"Specification/Functions.html#positional-parameters","text":"","title":"Positional Parameters"},{"location":"Specification/Functions.html#named-parameters","text":"","title":"Named Parameters"},{"location":"Specification/Functions.html#contracts","text":"","title":"Contracts"},{"location":"Specification/Functions.html#function-closures","text":"","title":"Function Closures"},{"location":"Specification/Keywords.html","text":"Keywords Keywords are special words is a specific meaning.","title":"Keywords"},{"location":"Specification/Keywords.html#keywords","text":"Keywords are special words is a specific meaning.","title":"Keywords"},{"location":"Specification/Operators.html","text":"Operators Precedence The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shift in , not in , < , > , <= , >= , != , == including test and comparisons & bitwise and ^ bitwise xor | bitwise or and logical and or logical or not logical not right-to-left","title":"Operators"},{"location":"Specification/Operators.html#operators","text":"","title":"Operators"},{"location":"Specification/Operators.html#precedence","text":"The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shift in , not in , < , > , <= , >= , != , == including test and comparisons & bitwise and ^ bitwise xor | bitwise or and logical and or logical or not logical not right-to-left","title":"Precedence"},{"location":"Specification/Scopes.html","text":"Scopes Global Scope In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code. Local Scope Local scopes are defined at function level and opened/closed with { and } respectively. let x = 0 # global if true { # not a scope let y = 0 # still global } func foo () { # local scope at function level let l = 0 return func () { # another local scope , can see all scope above but not the other way around return l } } Variable Capturring Chained Scopes","title":"Scopes"},{"location":"Specification/Scopes.html#scopes","text":"","title":"Scopes"},{"location":"Specification/Scopes.html#global-scope","text":"In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Global Scope"},{"location":"Specification/Scopes.html#local-scope","text":"Local scopes are defined at function level and opened/closed with { and } respectively. let x = 0 # global if true { # not a scope let y = 0 # still global } func foo () { # local scope at function level let l = 0 return func () { # another local scope , can see all scope above but not the other way around return l } }","title":"Local Scope"},{"location":"Specification/Scopes.html#variable-capturring","text":"","title":"Variable Capturring"},{"location":"Specification/Scopes.html#chained-scopes","text":"","title":"Chained Scopes"},{"location":"Specification/Variables.html","text":"Variables Declaration Variables are declared with the let keyword. Variables are by default read-only and can be declared with write capabilities by adding the mut keyword: let readonly = 0 let mut counter = 0","title":"Variables"},{"location":"Specification/Variables.html#variables","text":"","title":"Variables"},{"location":"Specification/Variables.html#declaration","text":"Variables are declared with the let keyword. Variables are by default read-only and can be declared with write capabilities by adding the mut keyword: let readonly = 0 let mut counter = 0","title":"Declaration"},{"location":"Syntax/Comments.html","text":"Comments Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: // next line prints : Hello , World io . print ( \"Hello, World\" ) /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Comments.html#comments","text":"Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: // next line prints : Hello , World io . print ( \"Hello, World\" ) /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Operators.html","text":"Operators Operator Precedence Precedence Operator Description 1 () Parentheses 2 foo() Function call . Member access ** Exponentiation * , / , // , % Multiplication, division and remainder + , - Addition and subtraction not value Boolean negation and Boolean conjunction or Boolean disjunction","title":"Operators"},{"location":"Syntax/Operators.html#operators","text":"","title":"Operators"},{"location":"Syntax/Operators.html#operator-precedence","text":"Precedence Operator Description 1 () Parentheses 2 foo() Function call . Member access ** Exponentiation * , / , // , % Multiplication, division and remainder + , - Addition and subtraction not value Boolean negation and Boolean conjunction or Boolean disjunction","title":"Operator Precedence"},{"location":"Syntax/Syntax.html","text":"Syntax EBFN Syntax","title":"Syntax"},{"location":"Syntax/Syntax.html#syntax","text":"","title":"Syntax"},{"location":"Syntax/Syntax.html#ebfn-syntax","text":"","title":"EBFN Syntax"},{"location":"Types/Numbers.html","text":"Numbers Integers Integers can be of arbitrary length if Bia was built with a supported big int library, otherwise the integers range from -2^63 to 2^63-1 . Floating points Floating point values are stored in a IEEE 754 double precision encoding. The internal encoding is platform specific. Integer literals The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Literal Base 0x or 0X Hexadecimal 0b or 0B Binary 0 Ocatal","title":"Numbers"},{"location":"Types/Numbers.html#numbers","text":"","title":"Numbers"},{"location":"Types/Numbers.html#integers","text":"Integers can be of arbitrary length if Bia was built with a supported big int library, otherwise the integers range from -2^63 to 2^63-1 .","title":"Integers"},{"location":"Types/Numbers.html#floating-points","text":"Floating point values are stored in a IEEE 754 double precision encoding. The internal encoding is platform specific.","title":"Floating points"},{"location":"Types/Numbers.html#integer-literals","text":"The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Literal Base 0x or 0X Hexadecimal 0b or 0B Binary 0 Ocatal","title":"Integer literals"},{"location":"Types/Regex.html","text":"Regex Syntax The pattern must be wrapped between / like following: let pattern = /ab+/ Modifiers Modifiers come immediately after the enclosing / like: let pattern = /a.+/si Modifier Meaning m ^ and $ match start/end of a line i case insensitive matching s . matches every character Supported underlying engines Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. PCRE2 default boost:regex std::regex If no engine is selected, the feature will be disabled and bia::exception::unsupported_feature_exception will be thrown when used. The underlying engine can be check with: // returns null if no engine is supported let engine = //.name()","title":"Regex"},{"location":"Types/Regex.html#regex","text":"","title":"Regex"},{"location":"Types/Regex.html#syntax","text":"The pattern must be wrapped between / like following: let pattern = /ab+/","title":"Syntax"},{"location":"Types/Regex.html#modifiers","text":"Modifiers come immediately after the enclosing / like: let pattern = /a.+/si Modifier Meaning m ^ and $ match start/end of a line i case insensitive matching s . matches every character","title":"Modifiers"},{"location":"Types/Regex.html#supported-underlying-engines","text":"Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. PCRE2 default boost:regex std::regex If no engine is selected, the feature will be disabled and bia::exception::unsupported_feature_exception will be thrown when used. The underlying engine can be check with: // returns null if no engine is supported let engine = //.name()","title":"Supported underlying engines"},{"location":"Types/Strings.html","text":"String Comparing strings Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. Iterating over strings When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). let string = \"a\u304c\" // prints 3 print ( string . length ) // prints a print ( string [ 0 ]) // prints the low surrogate and not \u304c print ( string [ 1 ]) The correct way to iterate over strings: for c in string { print(c) } The wrong way to iterate over string: for string.length times { print(string[$i]) } Normal strings 'Normal' strings are enclosed in either two \" (double quotes) or ' (single quotes). Normal strings can expand over multiple lines. Raw strings Raw strings cannot contain escape characters and can expand over mutliple lines. Template strings Template strings are enclosed between two ` (grave accents). Inside these strings normal Bia expression can be evaluated inside ${} and put inplace like following: let x = 1 let z = 9 // prints y = x + z = 10 print(`y = x + z = ${ x + z } `) Escape characters The following escape sequences are valid if the string is not a raw string . Escape sequence Meaning \\ Backslash \\' Single quote \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab \\nnn Arbitrary octal value \\xnn Arbitrary hexadecimal value \\unnnn Arbitrary Unicode value (hexadecimal) \\Unnnnnnnn Arbitrary Unicode value (hexadecimal) Guaranteed supported encodings Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE Supported underlying libraries ICU default If no library is provided only the guaranteed encodings here are supported. Internal implementation Bia strings are stored as UTF-16 internally with the default CPU endianess. By defaut static strings are interned. Limitations The maximum allowed string length cannot exceed 2^64-1 which is equal to 18 446 744 073 709 551 615 .","title":"Strings"},{"location":"Types/Strings.html#string","text":"","title":"String"},{"location":"Types/Strings.html#comparing-strings","text":"Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison.","title":"Comparing strings"},{"location":"Types/Strings.html#iterating-over-strings","text":"When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). let string = \"a\u304c\" // prints 3 print ( string . length ) // prints a print ( string [ 0 ]) // prints the low surrogate and not \u304c print ( string [ 1 ]) The correct way to iterate over strings: for c in string { print(c) } The wrong way to iterate over string: for string.length times { print(string[$i]) }","title":"Iterating over strings"},{"location":"Types/Strings.html#normal-strings","text":"'Normal' strings are enclosed in either two \" (double quotes) or ' (single quotes). Normal strings can expand over multiple lines.","title":"Normal strings"},{"location":"Types/Strings.html#raw-strings","text":"Raw strings cannot contain escape characters and can expand over mutliple lines.","title":"Raw strings"},{"location":"Types/Strings.html#template-strings","text":"Template strings are enclosed between two ` (grave accents). Inside these strings normal Bia expression can be evaluated inside ${} and put inplace like following: let x = 1 let z = 9 // prints y = x + z = 10 print(`y = x + z = ${ x + z } `)","title":"Template strings"},{"location":"Types/Strings.html#escape-characters","text":"The following escape sequences are valid if the string is not a raw string . Escape sequence Meaning \\ Backslash \\' Single quote \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab \\nnn Arbitrary octal value \\xnn Arbitrary hexadecimal value \\unnnn Arbitrary Unicode value (hexadecimal) \\Unnnnnnnn Arbitrary Unicode value (hexadecimal)","title":"Escape characters"},{"location":"Types/Strings.html#guaranteed-supported-encodings","text":"Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE","title":"Guaranteed supported encodings"},{"location":"Types/Strings.html#supported-underlying-libraries","text":"ICU default If no library is provided only the guaranteed encodings here are supported.","title":"Supported underlying libraries"},{"location":"Types/Strings.html#internal-implementation","text":"Bia strings are stored as UTF-16 internally with the default CPU endianess. By defaut static strings are interned.","title":"Internal implementation"},{"location":"Types/Strings.html#limitations","text":"The maximum allowed string length cannot exceed 2^64-1 which is equal to 18 446 744 073 709 551 615 .","title":"Limitations"}]}