{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Bia Dependencies No dependency is actually required, however, the bold printed dependecies are recommended and enabled by default. Dependency Usage Configuration Default std::thread BIA_THREAD_BACKEND=std::thread default and recommended Required for Testing Catch2 is required for testing and is in the repository included (no additional cloning). Building from Source Prerequisites: CMake (version 3.1) C++ compiler with at least C++11 support git The source code can be retrieved from GitHub with \u2764 1 2 3 git clone https://github.com/bialang/bia.git mkdir bia/build cd bia/build With CMake and the source code, the library can be build as follows: 1 2 cmake .. cmake --build . We recommend running the test before installing the library: 1 ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. 1 cmake --build . --target install","title":"Home"},{"location":"index.html#welcome-to-bia","text":"","title":"Welcome to Bia"},{"location":"index.html#dependencies","text":"No dependency is actually required, however, the bold printed dependecies are recommended and enabled by default. Dependency Usage Configuration Default std::thread BIA_THREAD_BACKEND=std::thread default and recommended","title":"Dependencies"},{"location":"index.html#required-for-testing","text":"Catch2 is required for testing and is in the repository included (no additional cloning).","title":"Required for Testing"},{"location":"index.html#building-from-source","text":"Prerequisites: CMake (version 3.1) C++ compiler with at least C++11 support git The source code can be retrieved from GitHub with \u2764 1 2 3 git clone https://github.com/bialang/bia.git mkdir bia/build cd bia/build With CMake and the source code, the library can be build as follows: 1 2 cmake .. cmake --build . We recommend running the test before installing the library: 1 ctest If every test passed, everthing is good to go and the following command can be run (elevated privileges may be required). However, if any test failed, please open an issue on GitHub. 1 cmake --build . --target install","title":"Building from Source"},{"location":"Engine/Engine.html","text":"Engine","title":"Engine"},{"location":"Engine/Engine.html#engine","text":"","title":"Engine"},{"location":"Engine/Memory.html","text":"Memory Garbage collector Stop the world Custom memory allocator","title":"Memory"},{"location":"Engine/Memory.html#memory","text":"","title":"Memory"},{"location":"Engine/Memory.html#garbage-collector","text":"","title":"Garbage collector"},{"location":"Engine/Memory.html#stop-the-world","text":"","title":"Stop the world"},{"location":"Engine/Memory.html#custom-memory-allocator","text":"","title":"Custom memory allocator"},{"location":"Engine/Op%20Codes.html","text":"Op Codes Parameter types Constant Member Source Member Destination Variantions 8 Bit Variants 4 Bit Variants 2 Bit Variants 0 Bit Variants Parameter types Constant Name Description Parameter Size Value int8 Signed int 8 bit 0 int16 Signed int 16 bit 1 int32 Signed int 32 bit 2 double IEEE 754 floating point 64 bit 3 Member Source Name Description Parameter Size Value tos Get top of stack 0 bit 0 args Get member with unsigned offset from arg position 8 bit 1 global16 local16 resource16 global8 local8 resource8 Member Destination Name Description Parameter Size Value tos Push on top of stack 0 bit 0 global16 local16 global8 local8 Variantions 8 Bit Variants Op Code 1. Parameter 2. Parameter 3. Parameter instantiate constant member destination n/a invoke uint8 parameter count member source member destination refer member source member destination n/a copy member source member destination n/a 4 Bit Variants Op Code 1. Parameter 2. Parameter invoke_void uint8 parameter count member source test member source n/a 2 Bit Variants Op Code 1. Parameter jump offset jump_true offset jump_false offset 0 Bit Variants Op Code return_void test_top","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#op-codes","text":"Parameter types Constant Member Source Member Destination Variantions 8 Bit Variants 4 Bit Variants 2 Bit Variants 0 Bit Variants","title":"Op Codes"},{"location":"Engine/Op%20Codes.html#parameter-types","text":"","title":"Parameter types"},{"location":"Engine/Op%20Codes.html#constant","text":"Name Description Parameter Size Value int8 Signed int 8 bit 0 int16 Signed int 16 bit 1 int32 Signed int 32 bit 2 double IEEE 754 floating point 64 bit 3","title":"Constant"},{"location":"Engine/Op%20Codes.html#member-source","text":"Name Description Parameter Size Value tos Get top of stack 0 bit 0 args Get member with unsigned offset from arg position 8 bit 1 global16 local16 resource16 global8 local8 resource8","title":"Member Source"},{"location":"Engine/Op%20Codes.html#member-destination","text":"Name Description Parameter Size Value tos Push on top of stack 0 bit 0 global16 local16 global8 local8","title":"Member Destination"},{"location":"Engine/Op%20Codes.html#variantions","text":"","title":"Variantions"},{"location":"Engine/Op%20Codes.html#8-bit-variants","text":"Op Code 1. Parameter 2. Parameter 3. Parameter instantiate constant member destination n/a invoke uint8 parameter count member source member destination refer member source member destination n/a copy member source member destination n/a","title":"8 Bit Variants"},{"location":"Engine/Op%20Codes.html#4-bit-variants","text":"Op Code 1. Parameter 2. Parameter invoke_void uint8 parameter count member source test member source n/a","title":"4 Bit Variants"},{"location":"Engine/Op%20Codes.html#2-bit-variants","text":"Op Code 1. Parameter jump offset jump_true offset jump_false offset","title":"2 Bit Variants"},{"location":"Engine/Op%20Codes.html#0-bit-variants","text":"Op Code return_void test_top","title":"0 Bit Variants"},{"location":"Examples/Hello%20World.html","text":"Hello, World This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bia/bia.hpp> #include <bia/bsl/io.hpp> #include <iostream> #include <sstream> int main () { bia :: engine engine ; engine . function ( \"hello_world\" , + [] { std :: cout << \"Hello, World! - C++ \\n \" ; }); engine . module < bia :: bsl :: io > ( \"io\" , engine . gc ()); std :: stringstream code ; code << u8R \"( // prints 'Hello, World' to the console import io io . print ( \"Hello, World! - Bia\" ) // calls the C++ function and print 'Hello, World - C++' to the console hello_world () ) \"; engine . execute ( code ); }","title":"Hello World"},{"location":"Examples/Hello%20World.html#hello-world","text":"This examples demonstrates how to bind a simple C++ function to an engine and then executing a small script. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bia/bia.hpp> #include <bia/bsl/io.hpp> #include <iostream> #include <sstream> int main () { bia :: engine engine ; engine . function ( \"hello_world\" , + [] { std :: cout << \"Hello, World! - C++ \\n \" ; }); engine . module < bia :: bsl :: io > ( \"io\" , engine . gc ()); std :: stringstream code ; code << u8R \"( // prints 'Hello, World' to the console import io io . print ( \"Hello, World! - Bia\" ) // calls the C++ function and print 'Hello, World - C++' to the console hello_world () ) \"; engine . execute ( code ); }","title":"Hello, World"},{"location":"Introduction/Cheatsheet.html","text":"Cheatsheet The Engine A Bia engine can be initialized like this: C++ 1 2 3 #include <bia/bia.hpp> bia :: engine engine ; C 1 2 3 4 5 6 #include <bia/cbia.h> bia_engine_t engine = bia_engine_new (); // always free afterwards bia_engine_free ( engine ); Go 1 2 3 4 5 6 7 8 9 import \"github.com/bialang/gobia\" engine , err := gobia . NewEngine () if err != nil { panic ( err ) } defer engine . Close () Executing a Script The bia::engine::execute function takes a std::istream for the script: C++ 1 2 3 4 #include <fstream> std :: ifstream file { \"myscript.bia\" }; engine . execute ( file ); Language Reference Variables 1 2 let x = 0 let x = null // x is deleted Looping Condition Based 1 2 3 4 5 6 7 8 9 while true { let line = io . read ( \"> \" ) if not line { break } io . print ( \"< You said:\" , line ) } Range Loops 1 2 3 4 5 6 7 for i in range ( 10 ) { io . print ( i ) } for m in r\"\\d+\" . match_all ( \"18.07.2020\" ) { io . print ( m . group ( 0 )) } Conditionals 1 2 3 4 5 if x and not y { io . print ( x ) } else if y { io . print ( y ) }","title":"Cheatsheet"},{"location":"Introduction/Cheatsheet.html#cheatsheet","text":"","title":"Cheatsheet"},{"location":"Introduction/Cheatsheet.html#the-engine","text":"A Bia engine can be initialized like this: C++ 1 2 3 #include <bia/bia.hpp> bia :: engine engine ; C 1 2 3 4 5 6 #include <bia/cbia.h> bia_engine_t engine = bia_engine_new (); // always free afterwards bia_engine_free ( engine ); Go 1 2 3 4 5 6 7 8 9 import \"github.com/bialang/gobia\" engine , err := gobia . NewEngine () if err != nil { panic ( err ) } defer engine . Close ()","title":"The Engine"},{"location":"Introduction/Cheatsheet.html#executing-a-script","text":"The bia::engine::execute function takes a std::istream for the script: C++ 1 2 3 4 #include <fstream> std :: ifstream file { \"myscript.bia\" }; engine . execute ( file );","title":"Executing a Script"},{"location":"Introduction/Cheatsheet.html#language-reference","text":"","title":"Language Reference"},{"location":"Introduction/Cheatsheet.html#variables","text":"1 2 let x = 0 let x = null // x is deleted","title":"Variables"},{"location":"Introduction/Cheatsheet.html#looping","text":"","title":"Looping"},{"location":"Introduction/Cheatsheet.html#condition-based","text":"1 2 3 4 5 6 7 8 9 while true { let line = io . read ( \"> \" ) if not line { break } io . print ( \"< You said:\" , line ) }","title":"Condition Based"},{"location":"Introduction/Cheatsheet.html#range-loops","text":"1 2 3 4 5 6 7 for i in range ( 10 ) { io . print ( i ) } for m in r\"\\d+\" . match_all ( \"18.07.2020\" ) { io . print ( m . group ( 0 )) }","title":"Range Loops"},{"location":"Introduction/Cheatsheet.html#conditionals","text":"1 2 3 4 5 if x and not y { io . print ( x ) } else if y { io . print ( y ) }","title":"Conditionals"},{"location":"Introduction/Embedding.html","text":"Embedding Bia's primary focus is to be easily embeddable into a C++11 application. For this purpose Bia exposes a simple wrapper class bia::engine (include <bia/bia.hpp> ). Native Functions Functions can be added with function , like: C++ 1 2 3 4 5 6 7 8 9 10 inline int square ( int x ) { return x * x ; } // static function engine . function ( \"square\" , & square ); // functor/lambda engine . function ( \"special\" , []( int x ) { return x * x ; }); C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static bia_creation_t square ( bia_parameters_t params , void * arg ) { bia_parameters_t param = 0 ; bia_creation_t result = 0 ; double x = 1.0 ; bia_parameters_at ( params , 0 , & param ); bia_member_cast_double ( param , & x ); bia_create_double ( x * x , & result ); return result ; } bia_engine_put_function ( engine , \"square\" , & square , 0 ); Advanced Functions Variable Parameters C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline int sum ( bia :: connector :: parameters_type params ) { int s = 0 ; // all parameters for ( auto param : params ) { if ( param ) { s += bia :: cast < int > ( * param ); } } return s ; } engine . function ( \"sum\" , & sum ); Generators C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bia/member/function/generator.hpp> inline bia :: gc :: gcable < bia :: member :: member > read_lines ( const char * filename ) { const auto file = std :: make_shared < std :: fstream > ( filename ); if ( ! file -> is_open ()) { return {}; } auto generator = [ file ]() -> bia :: gc :: gcable < bia :: member :: member > { std :: string line ; if ( std :: getline ( * file , line )) { return bia :: creator :: create ( line ); } return bia :: member :: function :: stop_iteration ; }; return bia :: gc :: gc :: active_gc () -> construct < bia :: member :: function :: generator < bia :: member :: function :: method < false , decltype ( & decltype ( generator ) :: operator ()) >>> ( generator , & decltype ( generator ) :: operator ()); }","title":"Embedding"},{"location":"Introduction/Embedding.html#embedding","text":"Bia's primary focus is to be easily embeddable into a C++11 application. For this purpose Bia exposes a simple wrapper class bia::engine (include <bia/bia.hpp> ).","title":"Embedding"},{"location":"Introduction/Embedding.html#native-functions","text":"Functions can be added with function , like: C++ 1 2 3 4 5 6 7 8 9 10 inline int square ( int x ) { return x * x ; } // static function engine . function ( \"square\" , & square ); // functor/lambda engine . function ( \"special\" , []( int x ) { return x * x ; }); C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static bia_creation_t square ( bia_parameters_t params , void * arg ) { bia_parameters_t param = 0 ; bia_creation_t result = 0 ; double x = 1.0 ; bia_parameters_at ( params , 0 , & param ); bia_member_cast_double ( param , & x ); bia_create_double ( x * x , & result ); return result ; } bia_engine_put_function ( engine , \"square\" , & square , 0 );","title":"Native Functions"},{"location":"Introduction/Embedding.html#advanced-functions","text":"","title":"Advanced Functions"},{"location":"Introduction/Embedding.html#variable-parameters","text":"C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline int sum ( bia :: connector :: parameters_type params ) { int s = 0 ; // all parameters for ( auto param : params ) { if ( param ) { s += bia :: cast < int > ( * param ); } } return s ; } engine . function ( \"sum\" , & sum );","title":"Variable Parameters"},{"location":"Introduction/Embedding.html#generators","text":"C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bia/member/function/generator.hpp> inline bia :: gc :: gcable < bia :: member :: member > read_lines ( const char * filename ) { const auto file = std :: make_shared < std :: fstream > ( filename ); if ( ! file -> is_open ()) { return {}; } auto generator = [ file ]() -> bia :: gc :: gcable < bia :: member :: member > { std :: string line ; if ( std :: getline ( * file , line )) { return bia :: creator :: create ( line ); } return bia :: member :: function :: stop_iteration ; }; return bia :: gc :: gc :: active_gc () -> construct < bia :: member :: function :: generator < bia :: member :: function :: method < false , decltype ( & decltype ( generator ) :: operator ()) >>> ( generator , & decltype ( generator ) :: operator ()); }","title":"Generators"},{"location":"Introduction/Getting%20Started.html","text":"Getting Started After installing Bia it can be used in your CMake projects: 1 2 3 4 find_package ( bia REQUIRED ) add_executable ( main \"main.cpp\" ) target_link_libraries ( main PUBLIC bia::bia ) For simple embedding in C++ including <bia/bia.hpp> and using bia::engine should be enough. For the C Port including <bia/cbia.h> and using bia_engine_t should be enough. Go 1 go get github.com/bialang/gobia","title":"Getting Started"},{"location":"Introduction/Getting%20Started.html#getting-started","text":"After installing Bia it can be used in your CMake projects: 1 2 3 4 find_package ( bia REQUIRED ) add_executable ( main \"main.cpp\" ) target_link_libraries ( main PUBLIC bia::bia ) For simple embedding in C++ including <bia/bia.hpp> and using bia::engine should be enough. For the C Port including <bia/cbia.h> and using bia_engine_t should be enough.","title":"Getting Started"},{"location":"Introduction/Getting%20Started.html#go","text":"1 go get github.com/bialang/gobia","title":"Go"},{"location":"Specification/Flow%20Control.html","text":"Flow Control Conditionals if , else if and else 1 2 3 4 5 6 7 if x { io . print ( \"x evaluates to true\" ) } else if not y { io . print ( \"x and y evaluate to false\" ) } else { io . print ( \"why am i here\" ) } Loops while 1 2 3 4 5 6 7 8 9 while x { io . print ( x ) if not y { break } x = y . something () } for...in 1 2 3 for i in range ( 10 ) { io . print ( i ) } In this case the variable i will be declared only for the loop and will not be available outside of the scope. If a variable already existed with the same name, it will be overshadowed.","title":"Flow Control"},{"location":"Specification/Flow%20Control.html#flow-control","text":"","title":"Flow Control"},{"location":"Specification/Flow%20Control.html#conditionals","text":"","title":"Conditionals"},{"location":"Specification/Flow%20Control.html#if-else-if-and-else","text":"1 2 3 4 5 6 7 if x { io . print ( \"x evaluates to true\" ) } else if not y { io . print ( \"x and y evaluate to false\" ) } else { io . print ( \"why am i here\" ) }","title":"if, else if and else"},{"location":"Specification/Flow%20Control.html#loops","text":"","title":"Loops"},{"location":"Specification/Flow%20Control.html#while","text":"1 2 3 4 5 6 7 8 9 while x { io . print ( x ) if not y { break } x = y . something () }","title":"while"},{"location":"Specification/Flow%20Control.html#forin","text":"1 2 3 for i in range ( 10 ) { io . print ( i ) } In this case the variable i will be declared only for the loop and will not be available outside of the scope. If a variable already existed with the same name, it will be overshadowed.","title":"for...in"},{"location":"Specification/Functions.html","text":"Functions Parameters Positional Parameters Named Parameters Contracts Function Closures","title":"Functions"},{"location":"Specification/Functions.html#functions","text":"","title":"Functions"},{"location":"Specification/Functions.html#parameters","text":"","title":"Parameters"},{"location":"Specification/Functions.html#positional-parameters","text":"","title":"Positional Parameters"},{"location":"Specification/Functions.html#named-parameters","text":"","title":"Named Parameters"},{"location":"Specification/Functions.html#contracts","text":"","title":"Contracts"},{"location":"Specification/Functions.html#function-closures","text":"","title":"Function Closures"},{"location":"Specification/Keywords.html","text":"Keywords Keywords are special words with a specific meaning. Keywords cannot be used as identifiers. let for in not , and and or while if else Builtins list range","title":"Keywords"},{"location":"Specification/Keywords.html#keywords","text":"Keywords are special words with a specific meaning. Keywords cannot be used as identifiers. let for in not , and and or while if else","title":"Keywords"},{"location":"Specification/Keywords.html#builtins","text":"list range","title":"Builtins"},{"location":"Specification/Scopes.html","text":"Scopes Global Scope In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Scopes"},{"location":"Specification/Scopes.html#scopes","text":"","title":"Scopes"},{"location":"Specification/Scopes.html#global-scope","text":"In the global scope all variables are stored with their names in a dictionary. This dictionary is accessible from everywhere in the code.","title":"Global Scope"},{"location":"Specification/Variables.html","text":"Variables Declaration Variables are declared with the let keyword. Variables are by default read-only: 1 let readonly = 0","title":"Variables"},{"location":"Specification/Variables.html#variables","text":"","title":"Variables"},{"location":"Specification/Variables.html#declaration","text":"Variables are declared with the let keyword. Variables are by default read-only: 1 let readonly = 0","title":"Declaration"},{"location":"Syntax/Comments.html","text":"Comments Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: 1 2 3 4 5 6 7 8 9 10 11 // next line prints: Hello, World io . print ( \"Hello, World\" ) /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Comments.html#comments","text":"Bia's comment style is similar to C++'s comments. Single line comments start with // and multiline comments start with /* and end with */ . Example: 1 2 3 4 5 6 7 8 9 10 11 // next line prints: Hello, World io . print ( \"Hello, World\" ) /* This is a multiline comment I can write anything here */","title":"Comments"},{"location":"Syntax/Operators.html","text":"Operators Special Behavior of the Logical Operators Logical And If the left-hand side can be converted to true , the right-hand side is returned; otherwise the left-hand side is returned: 1 2 io . print ( 99 and 61 ) // 61 io . print ( 0 and 61 ) // 0 Logical Or If the left-hand side can be converted to true , it is returned; otherwise the right-hand side is returned: 1 2 io . print ( 99 or 61 ) // 99 io . print ( 0 or 61 ) // 61 Precedence The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shifts & bitwise and ^ bitwise xor | bitwise or <=> three-way comparison in , < , > , <= , >= , != , == including test and comparisons not logical not right-to-left and logical and or logical or","title":"Operators"},{"location":"Syntax/Operators.html#operators","text":"","title":"Operators"},{"location":"Syntax/Operators.html#special-behavior-of-the-logical-operators","text":"","title":"Special Behavior of the Logical Operators"},{"location":"Syntax/Operators.html#logical-and","text":"If the left-hand side can be converted to true , the right-hand side is returned; otherwise the left-hand side is returned: 1 2 io . print ( 99 and 61 ) // 61 io . print ( 0 and 61 ) // 0","title":"Logical And"},{"location":"Syntax/Operators.html#logical-or","text":"If the left-hand side can be converted to true , it is returned; otherwise the right-hand side is returned: 1 2 io . print ( 99 or 61 ) // 99 io . print ( 0 or 61 ) // 61","title":"Logical Or"},{"location":"Syntax/Operators.html#precedence","text":"The following table shows Bia's operator precedence from highest to lowest. Operator Description Associativity a.b , a() , a[] member access, function call, subscript left-to-right ** exponentiation -a , ~a unary minus, bitwise not right-to-left * , / , % multiplication, division and remainder left-to-right + , - addition and subtraction << , >> bitwise shifts & bitwise and ^ bitwise xor | bitwise or <=> three-way comparison in , < , > , <= , >= , != , == including test and comparisons not logical not right-to-left and logical and or logical or","title":"Precedence"},{"location":"Types/List.html","text":"List builtin list 1 2 3 4 5 6 let empty = list () let my_list = list ( 1 , \"the second element\" , 3 ) for element in my_list { io . print ( element ) } Members push(elements...) pushes all given elements to the list pop(n=1) removes the last n elements clear() empties the list size the current size of the list capacity the capacity of the; this value describes after what size a push triggers a resize empty if the list is empty front the first element of the list back the last element of the list reserve(capacity) reserves more space shrink_to_fit() shrinks the list and releases unused memory insert(index, elements...) inserts the elements at the given index erase(index, n=1) erases from index n elements reverse() reverses the list inplace","title":"List"},{"location":"Types/List.html#list","text":"","title":"List"},{"location":"Types/List.html#builtin-list","text":"1 2 3 4 5 6 let empty = list () let my_list = list ( 1 , \"the second element\" , 3 ) for element in my_list { io . print ( element ) }","title":"builtin list"},{"location":"Types/List.html#members","text":"push(elements...) pushes all given elements to the list pop(n=1) removes the last n elements clear() empties the list size the current size of the list capacity the capacity of the; this value describes after what size a push triggers a resize empty if the list is empty front the first element of the list back the last element of the list reserve(capacity) reserves more space shrink_to_fit() shrinks the list and releases unused memory insert(index, elements...) inserts the elements at the given index erase(index, n=1) erases from index n elements reverse() reverses the list inplace","title":"Members"},{"location":"Types/Numbers.html","text":"Numbers Integers Integers in Bia range from -2^63 to 2^63-1 . Integer literals The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Base Literal Example Hexadecimal 0x or 0X 0xc0ffee Binary 0b or 0B 0b00100101 Ocatal 0 0777","title":"Numbers"},{"location":"Types/Numbers.html#numbers","text":"","title":"Numbers"},{"location":"Types/Numbers.html#integers","text":"Integers in Bia range from -2^63 to 2^63-1 .","title":"Integers"},{"location":"Types/Numbers.html#integer-literals","text":"The following literals can percede an integer digit and change the base of the number. If no literal is given, the decimal base is assumed. Base Literal Example Hexadecimal 0x or 0X 0xc0ffee Binary 0b or 0B 0b00100101 Ocatal 0 0777","title":"Integer literals"},{"location":"Types/Regex.html","text":"Native Regular Expressions Syntax The pattern must be wrapped between r\" and \" like following: 1 let pattern = r\"ab+\" Examples 1 2 3 4 5 6 7 8 9 10 11 12 // matches any digit let pattern = r\"\\d+\" io . print ( pattern == \"65\" ) // 1 io . print ( pattern in \"some string\" ) // 0 io . print ( pattern in \"i am 21 years old\" ) // 1 io . print ( pattern . match ( \"i am 21 years old\" )) // <null> io . print ( pattern . search ( \"i am 21 years old\" ). group ( 0 )) // 21 for i in pattern . match_all ( \"18.07.2020\" ) { io . print ( i . group ( 0 )) } Modifiers This has not been implemented yet Modifiers come immediately after the regex without any spaces: 1 let pattern = r\"a.+\" si Modifier Meaning Engine m ^ and $ match start/end of a line PCRE2; std::regex since C++17 i case insensitive matching all s . matches every character PCRE2 Supported underlying engines Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. std::regex default PCRE2 not supported 1 let engine_name = r\"\" . name","title":"Regex"},{"location":"Types/Regex.html#native-regular-expressions","text":"","title":"Native Regular Expressions"},{"location":"Types/Regex.html#syntax","text":"The pattern must be wrapped between r\" and \" like following: 1 let pattern = r\"ab+\"","title":"Syntax"},{"location":"Types/Regex.html#examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 // matches any digit let pattern = r\"\\d+\" io . print ( pattern == \"65\" ) // 1 io . print ( pattern in \"some string\" ) // 0 io . print ( pattern in \"i am 21 years old\" ) // 1 io . print ( pattern . match ( \"i am 21 years old\" )) // <null> io . print ( pattern . search ( \"i am 21 years old\" ). group ( 0 )) // 21 for i in pattern . match_all ( \"18.07.2020\" ) { io . print ( i . group ( 0 )) }","title":"Examples"},{"location":"Types/Regex.html#modifiers","text":"This has not been implemented yet Modifiers come immediately after the regex without any spaces: 1 let pattern = r\"a.+\" si Modifier Meaning Engine m ^ and $ match start/end of a line PCRE2; std::regex since C++17 i case insensitive matching all s . matches every character PCRE2","title":"Modifiers"},{"location":"Types/Regex.html#supported-underlying-engines","text":"Depending on the underlying engine different RegEx features are supported. For more information check out the engine documentations. std::regex default PCRE2 not supported 1 let engine_name = r\"\" . name","title":"Supported underlying engines"},{"location":"Types/Strings.html","text":"String Comparing Strings Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. 1 2 3 4 5 import io io . print ( \"bia\" == \"Bia\" ) // 0 io . print ( \"bia\" != \"Bia\" ) // 1 io . print ( \"Bia\" in \"I like Bia\" ) // 1 Members length the length of the strings (number of bytes not code points) lower() returns a copy of this string in lowercase upper() returns a copy of this string in uppercase Iterating over Strings This section is out of date When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). 1 2 3 4 let string = \"a\u304c\" // prints 3 print ( string . length ) Escape Characters Escape sequence Meaning \\ Backslash \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab Guaranteed supported Encodings Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE Internal Storage Bia strings are stored as UTF-8 internally.","title":"Strings"},{"location":"Types/Strings.html#string","text":"","title":"String"},{"location":"Types/Strings.html#comparing-strings","text":"Strings can be compared with the == or != operators or with equals or iequals for case-insensitive comparing. Additionally compare or icompare return an integer value describing the comparison. 1 2 3 4 5 import io io . print ( \"bia\" == \"Bia\" ) // 0 io . print ( \"bia\" != \"Bia\" ) // 1 io . print ( \"Bia\" in \"I like Bia\" ) // 1","title":"Comparing Strings"},{"location":"Types/Strings.html#members","text":"length the length of the strings (number of bytes not code points) lower() returns a copy of this string in lowercase upper() returns a copy of this string in uppercase","title":"Members"},{"location":"Types/Strings.html#iterating-over-strings","text":"This section is out of date When accessing characters at a specific position keep in mind that the code unit is returned and not the actual code point. When the string consists of only BMP characters all code units are also code points (see UTF-16 encoding). 1 2 3 4 let string = \"a\u304c\" // prints 3 print ( string . length )","title":"Iterating over Strings"},{"location":"Types/Strings.html#escape-characters","text":"Escape sequence Meaning \\ Backslash \\\" Double quote \\a Audible bell \\b Backspace \\f Form feed (new page) \\n Line feed (new line) \\r Carriage return \\t Horizontal tab \\v Vertical tab","title":"Escape Characters"},{"location":"Types/Strings.html#guaranteed-supported-encodings","text":"Depending on the underlying encoding implementation different encodings are supported. Always supported: ASCII UTF-8 UTF-16LE and UTF-16BE UTF-32LE and UTF-32BE","title":"Guaranteed supported Encodings"},{"location":"Types/Strings.html#internal-storage","text":"Bia strings are stored as UTF-8 internally.","title":"Internal Storage"}]}